You are in my Replit Trading App (TypeScript/Express backend + React frontend). The /scan endpoint is broken and now NOTHING scans. Fix it end-to-end so scans run again and the UI shows correct counts.

PROBLEM SUMMARY
- UI shows ‚ÄúStocks Scanned‚Äù and ‚ÄúReversals Detected‚Äù.
- Previously it returned something, now it returns nothing / scan doesn‚Äôt run.
- Current code has multiple issues:
  1) symbolsParam is referenced but not defined.
  2) reversalsDetected references `reversals.length` but `reversals` is not defined.
  3) scanMultipleStocks currently returns `ReversalSignal[]` (signals), but UI is treating results.length as ‚Äúscanned‚Äù.
  4) The route response structure is inconsistent / likely crashing.
  5) Need proper query parsing, defaults, error handling, and a stable JSON response shape.

GOAL
- /scan must ALWAYS return JSON with:
  summary: { totalScanned, analyzed, reversalsDetected, throttled, errors }
  results: ReversalSignal[]
  errorDetails: []
- totalScanned must equal number of symbols requested (attempted scans), not number of signals.
- Make it impossible for undefined vars to crash the route.
- Add logs so we can see it scanning in Replit console.

STEP 1 ‚Äî FIX THE ROUTE (Express)
Replace the entire /scan route with this working version:

router.get("/scan", async (req: Request, res: Response) => {
  try {
    const symbolsParam = typeof req.query.symbols === "string" ? req.query.symbols : undefined;

    const symbols =
      symbolsParam
        ? symbolsParam.split(",").map(s => s.trim().toUpperCase()).filter(Boolean)
        : DEFAULT_SYMBOLS.slice(0, 10);

    console.log("üì° /scan request symbols:", symbols);

    const report = await reversalDetectionService.scanMultipleStocks(symbols);

    return res.json({
      summary: {
        totalScanned: report.totals.attempted,
        analyzed: report.totals.analyzed,
        reversalsDetected: report.totals.emitted,
        throttled: report.totals.throttled,
        errors: report.totals.errors,
      },
      results: report.signals,
      errorDetails: report.errors,
    });
  } catch (err: any) {
    console.error("‚ùå /scan failed:", err);
    return res.status(500).json({
      summary: { totalScanned: 0, analyzed: 0, reversalsDetected: 0, throttled: 0, errors: 1 },
      results: [],
      errorDetails: [{ symbol: "SERVER", message: err?.message ?? String(err) }],
    });
  }
});

STEP 2 ‚Äî FIX scanMultipleStocks TO RETURN A REPORT (NOT JUST SIGNALS)
Replace scanMultipleStocks with this:

type ScanReport = {
  totals: {
    attempted: number;
    analyzed: number;
    signaled: number;
    emitted: number;
    throttled: number;
    errors: number;
  };
  signals: ReversalSignal[];
  errors: { symbol: string; message: string }[];
};

async scanMultipleStocks(symbols: string[]): Promise<ScanReport> {
  console.log(`üéØ REVERSAL SCANNER: Analyzing ${symbols.length} symbols...`);

  const totals = {
    attempted: symbols.length,
    analyzed: 0,
    signaled: 0,
    emitted: 0,
    throttled: 0,
    errors: 0,
  };

  const signals: ReversalSignal[] = [];
  const errors: { symbol: string; message: string }[] = [];

  for (const symbol of symbols) {
    try {
      totals.analyzed++;

      console.log(`üîç Analyzing ${symbol}...`);

      const signal = await this.analyzeStock(symbol);

      // IMPORTANT: analyzeStock must return null/undefined when no signal
      if (signal) {
        totals.signaled++;

        const throttleCheck = this.shouldThrottleAlert(symbol, signal);

        if (!throttleCheck.throttle) {
          signals.push(signal);
          totals.emitted++;
          console.log(`‚úÖ Signal emitted for ${symbol}`);
        } else {
          totals.throttled++;
          console.log(`üîá Throttled ${symbol}`);
        }
      } else {
        console.log(`‚ûñ No signal for ${symbol}`);
      }

      // Keep rate limit but make configurable later
      await new Promise((r) => setTimeout(r, 500));
    } catch (err: any) {
      totals.errors++;
      const msg = err?.message ?? String(err);
      errors.push({ symbol, message: msg });
      console.error(`‚ùå Error analyzing ${symbol}:`, msg);
    }
  }

  console.log("üìä Scan totals:", totals);

  return { totals, signals, errors };
}

STEP 3 ‚Äî VERIFY analyzeStock IS NOT THROWING / NOT HANGING
Add a timeout wrapper so one stuck symbol doesn‚Äôt stop scanning:

function withTimeout<T>(p: Promise<T>, ms: number, label: string): Promise<T> {
  return new Promise((resolve, reject) => {
    const t = setTimeout(() => reject(new Error(`${label} timed out after ${ms}ms`)), ms);
    p.then(v => { clearTimeout(t); resolve(v); }).catch(e => { clearTimeout(t); reject(e); });
  });
}

Then inside scan loop:

const signal = await withTimeout(this.analyzeStock(symbol), 15000, `analyzeStock(${symbol})`);

Also log inside analyzeStock:
- when fetch starts
- when fetch completes
- how many candles received
- if candle array empty, return null (do not throw)

STEP 4 ‚Äî FRONTEND: EXPECT NEW JSON SHAPE
Update UI to use:
scanData.summary.totalScanned
scanData.summary.reversalsDetected
(and optionally show analyzed/errors/throttled)

Make sure the frontend call uses the right route and handles errors:
- if response not ok, display errorDetails

STEP 5 ‚Äî QUICK TEST
In Replit console, hit:
GET /scan?symbols=AAPL,MSFT,TSLA

Expected:
- Console shows ‚ÄúAnalyzing AAPL‚Ä¶‚Äù
- JSON summary shows totalScanned: 3
- analyzed: 3
- reversalsDetected: 0+ depending on rules
- errors: 0 unless a provider failed

IMPORTANT NOTES
- Remove any reference to `reversals.length` in the route; it is a crash.
- Do NOT set totalScanned = results.length (signals). totalScanned must be attempted count.
- Ensure DEFAULT_SYMBOLS exists and is imported.
- Ensure the router file actually exports the router and is mounted (app.use("/api", router) etc.)

Now implement these exact changes and make /scan work again.
